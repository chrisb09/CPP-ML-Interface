@startuml CPP_NEW_ML_Interface

' Layout hints to encourage a tree-like rendering
top to bottom direction
' skinparam linetype ortho
skinparam classAttributeIconSize 0
skinparam backgroundColor #FFFFFF
skinparam class {
    BackgroundColor<<abstract>> LightYellow
    BorderColor Black
    ArrowColor Black
}


class "MLCoupling<In,Out>" {
    - provider: std::unique_ptr<MLCouplingProvider<In,Out>>
    - application: std::unique_ptr<MLCouplingApplication<In,Out>>
    - behavior: std::unique_ptr<MLCouplingBehavior>
    + MLCoupling(MLCouplingProvider<In,Out>*,
                 MLCouplingApplication<In,Out>*, MLCouplingBehavior* = nullptr)
    + ~MLCoupling()
    + ml_step()
}

class "MLCouplingProvider<In,Out>" <<abstract>> {
    + MLCouplingProvider()
    + send_data(MLCouplingData<In>)
    + inference(MLCouplingData<In>): MLCouplingData<Out>
}

class "MLCouplingApplication<In,Out>" <<abstract>> {
    + MLCouplingApplication(std::unique_ptr<MLCouplingDataProcessor<In,Out>> data_processor)
    + ~MLCouplingApplication()
    # data_processor: std::unique_ptr<MLCouplingDataProcessor<In,Out>>
    + init()
    + finalize()
    + step(bool, bool)
    # preprocess(MLCouplingData<In>): MLCouplingData<In>
    # coupling_step(MLCouplingData<In>)
    # ml_step(MLCouplingData<In>): MLCouplingData<Out>
    # postprocess(MLCouplingData<Out>): MLCouplingData<Out>
}

class "MLCouplingNormalization<In,Out>" <<abstract>> {
    + normalize_input(In*, int)
    + denormalize_output(Out*, int)
}

class "MLCouplingMinMaxNormalization<In,Out>" {
    - input_min: In
    - input_max: In
    - output_min: Out
    - output_max: Out
    + MLCouplingMinMaxNormalization(In, In, Out, Out)
    + normalize_input(In*, int)
    + denormalize_output(Out*, int)
}

class "MLCouplingApplicationTurbulenceClosure<In,Out>" {
    + preprocess(MLCouplingData<In>): MLCouplingData<In>
    + postprocess(MLCouplingData<Out>): MLCouplingData<Out>
    + coupling_step(MLCouplingData<In>)
    + ml_step(MLCouplingData<In>): MLCouplingData<Out>
    - uniform_filtering()
    - downsampling()
    - compute_tau_ij()
}

class "MLCouplingDataProcessor<In,Out>" {
    + input_data: MLCouplingData<In>
    + input_data_after_preprocessing: MLCouplingData<In>
    + output_data_before_postprocessing: MLCouplingData<Out>
    + output_data: MLCouplingData<Out>
    + MLCouplingDataProcessor(std::vector<In*>, std::vector<std::vector<int>>,
                              std::vector<Out*>, std::vector<std::vector<int>>,
                              MLCouplingNormalization<In,Out>*)
    + MLCouplingDataProcessor(MLCouplingData<In>, MLCouplingData<Out>,
                              MLCouplingNormalization<In,Out>*)
    # normalize_input(In&)
    # denormalize_output(Out&)
    - normalization: std::unique_ptr<MLCouplingNormalization<In,Out>>
}

class "MLCouplingData<T>" {
    + data: std::vector<T*>
    + data_dimensions: std::vector<std::vector<int>>
    + MLCouplingData(const std::vector<T*>&, const std::vector<std::vector<int>>&)
    + MLCouplingData()
}

class "MLCouplingBehavior" <<abstract>> {
    + should_perform_inference(): bool
    + time_step_delta(): int
    + should_send_data(): bool
}

class "MLCouplingBehaviorDefault" {
    + should_perform_inference(): bool
    + time_step_delta(): int
    + should_send_data(): bool
}

class "MLCouplingBehaviorPeriodic" {
    - step_count: long long
    - inference_interval: int
    - coupled_steps_before_inference: int
    - coupled_steps_stride: int
    - step_increment_after_inference: int
    + should_perform_inference(): bool
    + time_step_delta(): int
    + should_send_data(): bool
}

class "MLCouplingProviderPhydll<In,Out>" {
    + send_data(MLCouplingData<In>)
    + inference(MLCouplingData<In>): MLCouplingData<Out>
}

class "MLCouplingProviderAixelerate<In,Out>" {
    + send_data(MLCouplingData<In>)
    + inference(MLCouplingData<In>): MLCouplingData<Out>
}

class "MLCouplingProviderSmartsim<In,Out>" {
    + MLCouplingProviderSmartsim(std::string, int, int, int, int, int)
    + send_data(MLCouplingData<In>)
    + inference(MLCouplingData<In>): MLCouplingData<Out>
}

' Relationships
"MLCoupling<In,Out>" "1" ||--|| "1" "MLCouplingProvider<In,Out>" : owns
"MLCoupling<In,Out>" "1" ||--|| "1" "MLCouplingApplication<In,Out>" : owns
"MLCoupling<In,Out>" "1" ||--o| "0..1" "MLCouplingBehavior" : owns
"MLCouplingApplication<In,Out>" "1" ||--|| "1" "MLCouplingDataProcessor<In,Out>" : owns
"MLCouplingDataProcessor<In,Out>" "1" ||--o| "0..1" "MLCouplingNormalization<In,Out>" : owns
"MLCouplingDataProcessor<In,Out>" "1" o--|| "4" "MLCouplingData<T>" : uses
"MLCouplingNormalization<In,Out>" <|-- "MLCouplingMinMaxNormalization<In,Out>"

"MLCouplingApplication<In,Out>" <|-- "MLCouplingApplicationTurbulenceClosure<In,Out>"
"MLCouplingBehavior" <|-- "MLCouplingBehaviorDefault"
"MLCouplingBehavior" <|-- "MLCouplingBehaviorPeriodic"

"MLCouplingProvider<In,Out>" <|-- "MLCouplingProviderPhydll<In,Out>"
"MLCouplingProvider<In,Out>" <|-- "MLCouplingProviderAixelerate<In,Out>"
"MLCouplingProvider<In,Out>" <|-- "MLCouplingProviderSmartsim<In,Out>"

@enduml